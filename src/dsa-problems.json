{
    "languages": [
      { "value": "python", "label": "Python", "icon": "üêç" },
      { "value": "javascript", "label": "JavaScript", "icon": "‚ú®" },
      { "value": "java", "label": "Java", "icon": "‚òï" }
    ],
    "categories": ["Arrays", "Strings", "Linked Lists", "Trees", "Graphs", "Dynamic Programming"],
    "problems": [
      {
        "id": 1,
        "title": "Two Sum",
        "description": "Find two numbers in an array that add up to a specific target.",
        "difficulty": "Easy",
        "category": "Arrays",
        "tags": ["Hash Table", "Searching"],
        "solutions": {
          "python": "def two_sum(nums, target):\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []",
          "javascript": "function twoSum(nums, target) {\n    const numMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (numMap.has(complement)) {\n            return [numMap.get(complement), i];\n        }\n        numMap.set(nums[i], i);\n    }\n    return [];\n}",
          "java": "public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> numMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (numMap.containsKey(complement)) {\n            return new int[]{numMap.get(complement), i};\n        }\n        numMap.put(nums[i], i);\n    }\n    return new int[]{};\n}"
        },
        "analysis": {
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      },
      {
        "id": 2,
        "title": "Reverse String",
        "description": "Implement a function to reverse a given string in-place.",
        "difficulty": "Easy",
        "category": "Strings",
        "tags": ["Two Pointers", "In-place"],
        "solutions": {
          "python": "def reverse_string(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s",
          "javascript": "function reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n    return s;\n}",
          "java": "public void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left] = s[right];\n        s[right] = temp;\n        left++;\n        right--;\n    }\n}"
        },
        "analysis": {
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      },
      {
        "id": 3,
        "title": "Binary Tree Inorder Traversal",
        "description": "Traverse a binary tree in inorder (left-root-right) and return the node values.",
        "difficulty": "Medium",
        "category": "Trees",
        "tags": ["Recursion", "Stack"],
        "solutions": {
          "python": "def inorder_traversal(root):\n    result = []\n    def dfs(node):\n        if not node:\n            return\n        dfs(node.left)\n        result.append(node.val)\n        dfs(node.right)\n    dfs(root)\n    return result",
          "javascript": "function inorderTraversal(root) {\n    const result = [];\n    function dfs(node) {\n        if (!node) return;\n        dfs(node.left);\n        result.push(node.val);\n        dfs(node.right);\n    }\n    dfs(root);\n    return result;\n}",
          "java": "public List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    dfs(root, result);\n    return result;\n}\nprivate void dfs(TreeNode node, List<Integer> result) {\n    if (node == null) return;\n    dfs(node.left, result);\n    result.add(node.val);\n    dfs(node.right, result);\n}"
        },
        "analysis": {
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      },
      {
        "id": 4,
        "title": "Fibonacci Number",
        "description": "Find the nth Fibonacci number using dynamic programming.",
        "difficulty": "Medium",
        "category": "Dynamic Programming",
        "tags": ["Memoization", "Recursion"],
        "solutions": {
          "python": "def fibonacci(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]",
          "javascript": "function fibonacci(n) {\n    if (n <= 1) return n;\n    const dp = new Array(n + 1).fill(0);\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}",
          "java": "public int fibonacci(int n) {\n    if (n <= 1) return n;\n    int[] dp = new int[n + 1];\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}"
        },
        "analysis": {
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)"
        }
      },
      {
        "id": 5,
        "title": "Detect Cycle in Linked List",
        "description": "Determine if a linked list has a cycle using Floyd's cycle detection algorithm.",
        "difficulty": "Medium",
        "category": "Linked Lists",
        "tags": ["Two Pointers", "Floyd's Algorithm"],
        "solutions": {
          "python": "def has_cycle(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
          "javascript": "function hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n}",
          "java": "public boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}"
        },
        "analysis": {
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      }
    ]
  }
  